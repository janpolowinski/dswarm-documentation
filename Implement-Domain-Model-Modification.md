If you would like to implement modifications (incl. additions) of the [[domain model|domain-model]] in the [backend](https://github.com/dswarm/dswarm), you first need to identify, which parts are affected from these changes, i.e., e.g. whether they are located in the [model](https://github.com/dswarm/dswarm/tree/builds/unstable/persistence/src/main/java/org/dswarm/persistence/model) package (which is valid for the majority) or somewhere else. If the entities are located or should be located in the model package, then you need to create a POJO class for them or modify an existing one. 

### POJO Classes

POJO classes are implementations of a domain model entities. Since we make use of [JPA](http://en.wikibooks.org/wiki/Java_Persistence) as abstraction for persistence, you need to ensure the appropriate utilisation of the JPA annotations (you can also have a look at existing POJO classes, i.e., how they are utilised there, e.g., [ContentSchema](https://github.com/dswarm/dswarm/blob/builds/unstable/persistence/src/main/java/org/dswarm/persistence/model/schema/ContentSchema.java)). Furthermore, since we also make use of [Jackson](https://github.com/FasterXML/jackson) for data exchange (de-/serialisation), which can also handle [JAXB](http://wiki.fasterxml.com/JacksonJAXBAnnotations) annotations, you also need to ensure the appropriate utilisation of the Jackson/JAXB annotations (here you can also have a look at the existing POJO classes, i.e., how they are utilised there).

Each domain model entity implementation has it's companion proxy class to carry processing states etc. (e.g. [RetrievalType](https://github.com/dswarm/dswarm/blob/builds/unstable/persistence/src/main/java/org/dswarm/persistence/model/proxy/RetrievalType.java)) that are created when working with the domain model entities - however, that are not part of the domain model entity itself. The concrete companion proxy classes are simply for guaranteeing type-safeness of the carry POJO classes. Since the related logic is contain in the abstract proxy class (i.e. in [ProxyDMPObject](https://github.com/dswarm/dswarm/blob/builds/unstable/persistence/src/main/java/org/dswarm/persistence/model/proxy/ProxyDMPObject.java) and extended abstract classes), you can simply create a proxy class for your new POJO class and make sure that the class signature point to your POJO class and that you extend from the companion abstract proxy class (of the abstract POJO class your concrete POJO class extends from). You can also have a look at other concrete proxy classes, e.g., [ProxyContentSchema](https://github.com/dswarm/dswarm/blob/builds/unstable/persistence/src/main/java/org/dswarm/persistence/model/schema/proxy/ProxyContentSchema.java) to get an impression how should look like.

Each POJO class has it's companion util class as well to provide processing logic that can be applied on one or more (i.e. collection) objects (instances) of a domain model entity. Currently, the util classes mainly provide logic to completely compare objects of a certain POJO class with each other (see the `completeEquals` method in [DMPObjectUtils](https://github.com/dswarm/dswarm/blob/builds/unstable/persistence/src/main/java/org/dswarm/persistence/model/utils/DMPObjectUtils.java), since the `equals` implementations of the POJO classes compare only for identifier equality right now). This logic is also mainly generalized in the abstract POJO util classes. So you can also simply create a util class for your new domain model entity implementation, point to the POJO class in the class signature and ensure that it extends from the correct related abstract util class (see, e.g., [ContentSchemaUtils](https://github.com/dswarm/dswarm/blob/builds/unstable/persistence/src/main/java/org/dswarm/persistence/model/schema/utils/ContentSchemaUtils.java) to get an expression how it should look like).

### Metadata Repository Schema Generation

When you've finished creating and/or modifying your POJOs in the model package, then you can re-create the schema of the [[metadata repository|Glossary#metadata-repository]] (see also [[here|mysql-cheat-sheet]]). You can simply make use of the following Maven command to generate schema script automatically (you need to call this command within the `persistence` module (directory)):

    mvn hibernate4:export

The result should be a `schema.sql` script in the `target` directory of the `persistence` module.

Afterwards, you can utilise a diff tool of your choice to compare the new schema script with the existing on in [src/main/resources](https://github.com/dswarm/dswarm/blob/builds/unstable/persistence/src/main/resources/schema.sql). Now it's getting a bit complicated (right now). You should only change (insert, remove, ...) necessary parts of the script.

1. You can skip the "alter table" part (at the beginning!) of the new script (since we make use of `SET foreign_key_checks = 0;` at the beginning of the script to unlock foreign key constraints, when processing the script (they will be enabled at the end of the script))
2. At the "drop table" part the relevant changes should be easily visible in your diff tool (i.e. often it's just the case that a new table should be dropped as well or that existing one was renamed)
3. At the following "create table" and "alter table" parts the relevant changes should also be easily visible in your diff tool (note: sometimes it's the case that the generated foreign key identifier change over the whole script - then it might be a bit difficult to just cherry pick only the new ones)

It's recommended to change smaller parts step-by-step and compare the result with the diff tool again. Generally, it's also recommended to apply all these changes to the schema script with care, since it's an essential part of the application.

### Persistence Services

Each POJO class (domain model entity implementation) has a companion persistence service (you can probably view them as [DAO](http://en.wikipedia.org/wiki/Data_access_object)) that is located in/below the [src/main/java/org/dswarm/persistence/service](https://github.com/dswarm/dswarm/tree/builds/unstable/persistence/src/main/java/org/dswarm/persistence/service) package. These service take care of the communication/handling with the metadata repository (e.g. read objects, write objects, database transactions etc.). 

Depending on which abstract [DMPObject](https://github.com/dswarm/dswarm/blob/builds/unstable/persistence/src/main/java/org/dswarm/persistence/model/DMPObject.java) implementation your POJO relies on, you'll also find a companion abstract persistence service where your concrete domain model entity persistence service can extend from (e.g. [BasicJPAService](https://github.com/dswarm/dswarm/blob/builds/unstable/persistence/src/main/java/org/dswarm/persistence/service/BasicJPAService.java)). You can have a look at other concrete domain model entity persistence service classes, e.g., [ContentSchemaService](https://github.com/dswarm/dswarm/blob/builds/unstable/persistence/src/main/java/org/dswarm/persistence/service/schema/ContentSchemaService.java) to get an expression which methods just need to be overwritten/implemented there. 

Mainly, you need to take care of decoupling related objects when deleting a persistently stored object (see the `prepareObjectForRemoval`method) and setting related objects when an update should be processed on the object (see the `updateObjectInternal` method). Make sure to also updated existing POJO persistence services as needed (e.g. when you've introduced a new relationship to another domain model entity).

### Persistence Layer Tests

Now it's time to test your domain model modifications. It's a good choice to first test the single parts and then the affected compound entities (that make use of e.g. the new entity that was introduced in you domain model modification). You can (optionally) first create unit tests in/below the [src/test/java/org/dswarm/persistence/model](https://github.com/dswarm/dswarm/tree/builds/unstable/persistence/src/test/java/org/dswarm/persistence/model) package (depending where your domain model POJOs are located). However, the more important step is to create integration tests to verify the functionality of your domain model modifications in context of the persistence layer, i.e., that the objects are stored as intended in the metadata repository. 